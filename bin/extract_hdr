#!/usr/bin/python
# vim:tw=0:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""extract_hdr: 

usage:
    -h | --help         print this message
*   -o | --output_dir   place to put extracted files. (creates output 
                        dir structure here)
    -i | --input_file   only extract one file (output to output_dir)
    -d | --input_dir    extract all files in dir (recursively) 
    -s | --systemid_conf specify config file of sysid <-> name mappings, to
                        give friendly names to BIOS RPMS.
    -t| --force_type   to build RPMs for firmwares apart from bios and raid

-- Required parameters are denoted by an asterisk (*)

"""

from __future__ import generators

version = "1.9"

# import arranged alphabetically
import ConfigParser
import fcntl
import getopt
import glob
import os
import Queue
import sys
import shutil
import traceback
import string
from threading import Thread
import time
import xmlrpclib

import firmwaretools.ini_thread_proxy
import firmwaretools.pycompat as pycompat
import firmwaretools.extract_common as extract_common
import firmwaretools.trace_decorator as trace_decorator
from firmwaretools.trace_decorator import trace
import firmwaretools
sys.path.append(firmwaretools.__path__[0])

processFunctions = []
handledExtensions = [ ]
versionArray = []
modules = [ "extract_bios", "extract_bmc", "extract_lsi" ]
#modules = [ "extract_bios", "extract_lsi" ]

unableToProcessStr = "UNPROCESSED: Version %s unable to process"

@trace
def extractHdr(ini, filename, outputDir, numFiles, thisNum):
    ret = 0
    global version
    global forceRebuild
    outPrefix = "%04i/%04i %s File: %s" % (thisNum, numFiles, os.getpid(), filename)

    if ini.has_option("processed_files", filename) and not forceRebuild:

        procString = ini.get("processed_files", filename)

        if procString == unableToProcessStr:
            print "%s Version %s not able to process..." % (outPrefix, version)
            sys.stdout.flush()
            return ret

        try:
            if procString.startswith("PROCESSED(%s):" % version):
                functName = procString.split(":")[1].strip()
                functVer  = procString.split(":")[2].strip()
                for n, f, v in processFunctions:
                    if n == functName and v == functVer:
                        print "%s Already processed by this version, skipping..." % outPrefix
                        sys.stdout.flush()
                        return 1
        except IndexError:
            pass

    handled = 0
    for i in handledExtensions:
        if filename.lower().endswith(i):
            handled = 1
            break

    nameOfHandler = None
    if handled:
        oldpwd = os.getcwd()
        tempdir = pycompat.mktempdir()
        try:
            destFile = os.path.join(tempdir, os.path.basename(filename))
            pycompat.copyFile(filename, destFile)
            os.chdir(tempdir)
            for name, function, functVersion in processFunctions:
                try:
                    ret = function(ini, filename, destFile, outputDir)
                    if ret:
                        ini.set("processed_files", filename, "PROCESSED(%s): %s:%s" % (version, name, functVersion))
                        nameOfHandler = name
                        break
                except extract_common.skip:
                    pass
                except KeyboardInterrupt:
                    raise
                except Exception:
                    #traceback.print_exc()
                    pass

        finally:
            os.chdir(oldpwd)
            os.system("chmod -R u+rw %s" % tempdir)
            shutil.rmtree(tempdir)

    if nameOfHandler is not None:
        print "%s good: %s" % (outPrefix, nameOfHandler)
    else:
        print "%s: unable to process " % outPrefix
        ini.set("processed_files", filename, unableToProcessStr)

    sys.stdout.flush()
    return ret

forceRebuild = 0
def main():
    inputDir=[]
    inputFiles=[]
    outputDir=None
    forceType=None
    ini = None
    extract_common.systemConfIni = ConfigParser.ConfigParser()

    iniThread = None
    numProcesses = 30

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hd:i:o:s:ft:vp:", [
                "help", "input_file=", "output_dir=",
                "systemid_conf=", "force", "input_dir=", "force_type=",
                "parallel=",
            ])
        for option, argument in opts:
            if option in ("-h", "--help"):
                print __doc__
                sys.exit(0)
            if option in ("-o", "--output_dir"):
                outputDir = argument
            if option in ("-p", "--parallel"):
                numProcesses = argument
            if option in ("-f", "--force"):
                global forceRebuild
                forceRebuild = 1
            if option in ("-i", "--input_file"):
                for f in glob.glob(os.path.realpath(argument)):
                    inputFiles.append(os.path.realpath(f))
            if option in ("-d", "--input_dir"):
                inputDir.append(argument)
            if option in ("-s", "--systemid_conf"):
                print "reading config file: %s" % argument        
                extract_common.systemConfIni.read(glob.glob(os.path.realpath(argument)))
            if option in ("-t", "--force_type"):
                forceType=str("%s" % argument)
                modules.append("extract_%s" % forceType)
            if option in ("-v", "--verbose"):
                trace_decorator.debug["__main__"] = 9
        
        if outputDir is None: raise getopt.GetoptError("Need output dir", "")

        global processFunctions, handledExtensions, versionArray, unableToProcessStr
        for m in modules:
            module = __import__(m, globals(), locals(), [])
            processFunctions.extend(module.processFunctions)
            handledExtensions.extend(module.handledExtensions)
            versionArray.append( (m, module.version))

        unableToProcessStr = unableToProcessStr % versionArray

        outputDir = os.path.realpath(outputDir)
        if not os.path.exists(outputDir):
            os.makedirs(outputDir)

        oldpwd = os.getcwd()
        os.chdir(outputDir)

        if not os.access("out", os.F_OK):
            os.mkdir("out")

        ini = ConfigParser.ConfigParser()
        ini.read( os.path.join(outputDir, "out", "config.ini"))
        if not ini.has_section("processed_files"):
            ini.add_section("processed_files")

        if not ini.has_section("out_files"):
            ini.add_section("out_files")

        if not ini.has_section("main"):
            ini.add_section("main")

        port = 8000
        iniThread = firmwaretools.ini_thread_proxy.XmlRpcThread(threadNumber=0, port=port, iniPath=os.path.join(outputDir, "out", "config.ini"), ini=ini)
        ini = xmlrpclib.Server('http://localhost:%s' % port)

        start = time.time()
        while not iniThread.running:
            time.sleep(0.1)
            if (time.time() - start > 2):
                print "timeout waiting for config parser to startup"
                raise KeyboardInterrupt()

        for argument in inputDir:
            print "walking input directories"
            for topdir, dirlist, filelist in pycompat.walkPath(os.path.realpath(argument)):
                filelist.sort()
                for file in filelist:
                    inputFiles.append(os.path.join(topdir,file))

        children=[]
        inputFiles.sort()
        numInputFiles = len(inputFiles)
        for index in xrange(numInputFiles):
            hdrFile = inputFiles[index]
            # only let configured number of children at once
            while len(children) > numProcesses:
                child, status = os.waitpid(0,0)
                children.remove(child)

            # one of the children had to have finished, so sync the config file
            iniThread.sync()
                
            sys.stdout.flush()
            sys.stderr.flush()
            pid = os.fork()
            if pid: # parent
                children.append(pid)
            else: #child
                try:
                    # make sure we close inherited filehandles
                    # or we could hold open sockets, etc.
                    for i in xrange(3,255): 
                        try:
                            os.close(i)
                        except OSError:
                            pass
                    extractHdr(ini, hdrFile, outputDir, thisNum=index, numFiles=numInputFiles)
                except (KeyboardInterrupt):
                    os._exit(0)
                except (Exception), e:
                    import traceback
                    traceback.print_exc()
                except: 
                    pass

                os._exit(0)

        #wait for everybody to finish up.
        iniThread.sync()
        while len(children):
            child, status = os.waitpid(0,0)
            iniThread.sync()
            children.remove(child)

        iniThread.sync()
        ini.kill()
        print "Finished in %s seconds" % (time.time() - start)

    except (getopt.GetoptError):
        # print help information and exit:
        print __doc__
        sys.exit(2)

    except (KeyboardInterrupt):
        try:
            print "kill ini thread."
            ini.kill()
            print "wait for all children to finish"
            os.wait()
        except:
            import traceback
            traceback.print_exc()
            
        sys.exit(3)

    except Exception:
        ini.kill()

    return 0 #shell logic

if __name__ == "__main__":
    sys.exit( main() )
