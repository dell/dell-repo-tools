#!/usr/bin/python
# vim:tw=0:expandtab:autoindent:tabstop=4:shiftwidth=4:filetype=python:

  #############################################################################
  #
  # Copyright (c) 2005 Dell Computer Corporation
  # Dual Licenced under GNU GPL and OSL
  #
  #############################################################################
"""extract_hdr: 

usage:
    -h | --help         print this message
*   -o | --output_dir   place to put extracted files. (creates output 
                        dir structure here)
    -i | --input_file   only extract one file (output to output_dir)
    -d | --input_dir    extract all files in dir (recursively) 
    -s | --systemid_conf specify config file of sysid <-> name mappings, to
                        give friendly names to BIOS RPMS.
    -t| --force_type   to build RPMs for firmwares apart from bios and raid

-- Required parameters are denoted by an asterisk (*)

"""

from __future__ import generators

version = "1.9"

# import arranged alphabetically
import ConfigParser
import fcntl
import getopt
import glob
import os
import Queue
import sys
import shutil
import traceback
import string
from threading import Thread
import time
import xmlrpclib

import firmwaretools.ini_thread_proxy
import firmwaretools.pycompat as pycompat
import firmwaretools.extract_common as extract_common
import firmwaretools.trace_decorator as trace_decorator
from firmwaretools.trace_decorator import trace
import firmwaretools
sys.path.append(firmwaretools.__path__[0])

processFunctions = []
handledExtensions = [ ]
versionArray = []
modules = [ "extract_bios", "extract_bmc", "extract_lsi" ]
#modules = [ "extract_bios", "extract_lsi" ]

unableToProcessStr = "UNPROCESSED: Version %s unable to process"

@trace
def extractHdr(ini, filename, outputDir):
    ret = 0
    global version
    global forceRebuild
    if ini.has_option("processed_files", filename) and not forceRebuild:

        procString = ini.get("processed_files", filename)

        if procString == unableToProcessStr:
            print "File(%s) %s Version %s not able to process..." % (os.getpid(), filename,version)
            sys.stdout.flush()
            return ret

        try:
            if procString.startswith("PROCESSED(%s):" % version):
                functName = procString.split(":")[1].strip()
                functVer  = procString.split(":")[2].strip()
                for n, f, v in processFunctions:
                    if n == functName and v == functVer:
                        print "File(%s) %s Already processed by this version, skipping..." % (os.getpid(), filename)
                        sys.stdout.flush()
                        return 1
        except IndexError:
            pass

    handled = 0
    ini.set("processed_files", filename, unableToProcessStr)
    for i in handledExtensions:
        if filename.lower().endswith(i):
            handled = 1
            break

    nameOfHandler = None
    if handled:
        oldpwd = os.getcwd()
        tempdir = pycompat.mktempdir()
        try:
            destFile = os.path.join(tempdir, os.path.basename(filename))
            pycompat.copyFile(filename, destFile)
            os.chdir(tempdir)
            for name, function, functVersion in processFunctions:
                try:
                    ret = function(ini, filename, destFile, outputDir)
                    if ret:
                        ini.set("processed_files", filename, "PROCESSED(%s): %s:%s" % (version, name, functVersion))
                        nameOfHandler = name
                        break
                except extract_common.skip:
                    pass
                except KeyboardInterrupt:
                    raise
                except Exception:
                    #traceback.print_exc()
                    pass

        finally:
            os.chdir(oldpwd)
            shutil.rmtree(tempdir)

    if nameOfHandler is not None:
        print "File(%s) %s good: %s" % (os.getpid(), filename, nameOfHandler)
    else:
        print "File(%s) %s: unable to process " % (os.getpid(), filename)

    sys.stdout.flush()
    return ret

forceRebuild = 0
def main():
    inputDir=[]
    inputFiles=[]
    outputDir=None
    forceType=None
    ini = None
    extract_common.systemConfIni = ConfigParser.ConfigParser()

    threadlist = []
    numProcesses = 30

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hd:i:o:s:ft:vp:", [
                "help", "input_file=", "output_dir=",
                "systemid_conf=", "force", "input_dir=", "force_type=",
                "parallel=",
            ])
        for option, argument in opts:
            if option in ("-h", "--help"):
                print __doc__
                sys.exit(0)
            if option in ("-o", "--output_dir"):
                outputDir = argument
            if option in ("-p", "--parallel"):
                numProcesses = argument
            if option in ("-f", "--force"):
                global forceRebuild
                forceRebuild = 1
            if option in ("-i", "--input_file"):
                for f in glob.glob(os.path.realpath(argument)):
                    inputFiles.append(os.path.realpath(f))
            if option in ("-d", "--input_dir"):
                inputDir.append(argument)
            if option in ("-s", "--systemid_conf"):
                print "reading config file: %s" % argument        
                extract_common.systemConfIni.read(glob.glob(os.path.realpath(argument)))
            if option in ("-t", "--force_type"):
                forceType=str("%s" % argument)
                modules.append("extract_%s" % forceType)
            if option in ("-v", "--verbose"):
                trace_decorator.debug["__main__"] = 9
        
        if outputDir is None: raise getopt.GetoptError("Need output dir", "")

        global processFunctions, handledExtensions, versionArray, unableToProcessStr
        for m in modules:
            module = __import__(m, globals(), locals(), [])
            processFunctions.extend(module.processFunctions)
            handledExtensions.extend(module.handledExtensions)
            versionArray.append( (m, module.version))

        unableToProcessStr = unableToProcessStr % versionArray

        outputDir = os.path.realpath(outputDir)
        if not os.path.exists(outputDir):
            os.makedirs(outputDir)

        oldpwd = os.getcwd()
        os.chdir(outputDir)

        if not os.access("out", os.F_OK):
            os.mkdir("out")

        ini = ConfigParser.ConfigParser()
        ini.read( os.path.join(outputDir, "out", "config.ini"))
        if not ini.has_section("processed_files"):
            ini.add_section("processed_files")

        if not ini.has_section("out_files"):
            ini.add_section("out_files")

        if not ini.has_section("main"):
            ini.add_section("main")

        port = 8000
        threadlist.append(firmwaretools.ini_thread_proxy.XmlRpcThread(threadNumber=0, port=port, iniPath=os.path.join(outputDir, "out", "config.ini"), ini=ini))
        ini = xmlrpclib.Server('http://localhost:%s' % port)

        start = time.time()
        while not threadlist[0].running:
            time.sleep(0.1)
            if (time.time() - start > 2):
                print "timeout waiting for config parser to startup"
                raise KeyboardInterrupt()

        for argument in inputDir:
            print "walking input directories"
            for topdir, dirlist, filelist in pycompat.walkPath(os.path.realpath(argument)):
                filelist.sort()
                for file in filelist:
                    inputFiles.append(os.path.join(topdir,file))

        children=[]
        inputFiles.sort()
        for hdrFile in inputFiles:
            threadlist[0].sync()
            while len(children) > numProcesses:
                child, status = os.waitpid(0,0)
                children.remove(child)
                
            pid = os.fork()
            if pid: # parent
                children.append(pid)
            else: #child
                try:
                    for i in xrange(3,255): 
                        try:
                            os.close(i)
                        except OSError:
                            pass
                    extractHdr(ini, hdrFile, outputDir)
                except (KeyboardInterrupt):
                    os._exit(0)
                except (Exception), e:
                    import traceback
                    traceback.print_exc()

                os._exit(0)

    except (getopt.GetoptError):
        # print help information and exit:
        print __doc__
        sys.exit(2)

    except (KeyboardInterrupt):
        try:
            print "Syncing INI file before Interrupt."
            ini.sync()
            print "kill ini thread."
            ini.kill()
            print "wait"
            os.wait()
        except:
            import traceback
            traceback.print_exc()
            
        sys.exit(3)

    except:
        for t in threadlist:
            t.kill()

    return 0 #shell logic

if __name__ == "__main__":
    sys.exit( main() )
